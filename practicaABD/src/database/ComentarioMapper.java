package database;
import model.Comentario;
import model.UserKeys;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;







//Imports para pruebas en main
import javax.sql.DataSource;

import com.mysql.jdbc.jdbc2.optional.MysqlDataSource;
//---

public class ComentarioMapper extends AbstractMapper<Comentario,UserKeys> {

	public ComentarioMapper(DataSource dataSource) {
		super(dataSource);
		// TODO Auto-generated constructor stub
	}

	@Override
	protected String getTableName() {
		// TODO Auto-generated method stub
		return model.Constants.COMENTARIO_TABLE;
	}

	@Override
	protected String[] getColumnNames() {
		// TODO Auto-generated method stub
		return new String[]{"id_comentario", "id_usr", "comentario", "fecha"};
	}
	
	//@SuppressWarnings("null")
	@Override
	protected Comentario buildObject(ResultSet rs) throws SQLException {
		Comentario result = new Comentario();
		result.setId_comentario(rs.getLong("id_comentario"));
		result.setId_usr(rs.getString("id_usr"));
		result.setComentario(rs.getString("comentario"));
		result.setFecha(rs.getTimestamp("fecha"));//cargamos Timestamp(sql) -> Date(not sql, contiene h/m/s cosa que el sql.Date carece)
		return result;
	}

	@Override
	protected Object[] serializeKey(UserKeys key) {
		// TODO Auto-generated method stub
		return new Object[] { key.getKey() };
	}

	@Override
	protected Object[] serializeObject(Comentario object) {//falta fecha
		// TODO Auto-generated method stub
		return new Object[] {object.getId_comentario(),object.getId_usr(),object.getComentario(),object.getFecha()};
	}

	@Override
	protected String[] getKeyColumnNames() {
		String[] keyCol={"id_comentario"};
		return keyCol;
	}

	@Override
	protected UserKeys getKey(Comentario obj) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	protected void fill(PreparedStatement pst, Comentario obj, boolean ins) {
		Date date = new Date();//creamos un objeto fecha
		try {	
			pst.setLong(1, obj.getId_comentario());// ? id_comentario
			pst.setString(2,obj.getId_usr());// ? id_usr
			pst.setString(3,obj.getComentario());// ? comentario
			Timestamp timestamp = new Timestamp(date.getTime());//rellenamos el timestamp con la fecha-hora actual que hemos obtenido del obj fecha
			pst.setTimestamp(4, timestamp);//? fecha , con la fecha-hora actual
			if(!ins){//si es update necesitamos rellenar la condicion where con el nick .
				pst.setLong(5, obj.getId_comentario());
			}
			
		} catch (SQLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	@Override
	protected String pharseUpdate() {
		String colNam[] = getColumnNames();
		String str = colNam[0]+"= ? ,"+colNam[1]+"= ? ,"+colNam[2]+"= ? ,"+colNam[3]+"= ? where "+colNam[0]+"= ? ";
		return str;
	}

	@Override
	protected String pharseInsert() {
		String colNam[] = getColumnNames();
		String str = " ("+colNam[0]+","+colNam[1]+","+colNam[2]+","+colNam[3]+")"
		+ " values " + " ( ?  , ? , ? , ? ) ";
		return str;
	}
	/**
	 * Se encarga de buscar todos los comentarios relativos a una serie/episodio y devolver un List con los comentarios.
	 * Este método es relativo al punto 5.1 y 5.2 del enunciado de la práctica.
	 * @param id de los episodios/series que queremos encontrar los comentarios.
	 * @param tipo para elegir si queremos comentarios de episodios->true o series->false.
	 * @return ArrayList de Objetos Comentario.
	 */
/*	public List<Comentario> comentarios(long id, boolean tipo ){	
		Connection con =null;
		PreparedStatement pst=null;
		ResultSet rs=null;
		Comentario coment=new Comentario();
		 List<Comentario> commList = new ArrayList<Comentario>();
		try{
			con= ds.getConnection();//Attempts to establish a connection with the data source that this DataSource object represents.
			String sql,aux=null,aux2=null;
			
			if(tipo){
				aux= " relcomepi ";
				aux2 = " id_epi= ";			
			}else if (!tipo){
				aux= " relcomser ";
				aux2=" id_ser= ";				
			}
			String [] aux3= getColumnNames();
			String [] aux4=getKeyColumnNames();
			
			sql= " SELECT "+aux3[0]+","+aux3[1]+","+aux3[2]+","+aux3[3]+" from "+getTableName() + " natural join "+ aux +" where " + aux2 + id + " and id_com = "+aux4[0] ;
			pst = con.prepareStatement(sql);//An object that represents a pre-compiled SQL statement. 
			
			rs=pst.executeQuery();//Executes the SQL query in this PreparedStatement object and returns the ResultSet object generated by the query
			
			while(rs.next()){	
				coment = buildObject(rs);//build the object obtain from the select
				commList.add(coment);
			}
		}catch (SQLException e){
			e.printStackTrace();
		}finally{
			try{
				if(rs!=null) rs.close();
				if(pst!=null) pst.close();
				if(con!=null) con.close();
			}catch (Exception e){}
		}
		return commList;
	}	*/
	public long getLastIndexInsert() {
		Connection con =null;
		PreparedStatement pst=null;
		ResultSet rs=null;
		Long result=null;
		try{
			con= ds.getConnection();//Attempts to establish a connection with the data source that this DataSource object represents.
			String sql="SELECT MAX( id_comentario ) AS id FROM comentario";
			pst = con.prepareStatement(sql);//An object that represents a pre-compiled SQL statement. 
			rs=pst.executeQuery();//Executes the SQL query in this PreparedStatement object and returns the ResultSet object generated by the query
			
			while(rs.next()){	
				result = rs.getLong("id");
			}
		}catch (SQLException e){
			e.printStackTrace();
		}finally{
			try{
				if(rs!=null) rs.close();
				if(pst!=null) pst.close();
				if(con!=null) con.close();
			}catch (Exception e){}
		}
		return result;
	}
	/**
	 * Método génerico que se encarga de devolver lista de objetos de la BBDD.
	 * Se utiliza especialmente para devolver ArrayList de comentarios, es decir, devuelve comentarios tanto de series como de episodios dependiendo 
	 * de los valores que toma boolean m.Sección 5.1 y 5.2 
	 * @param id en el caso de los comentarios de la serie/episodio
	 * @param m true -> episodios , false-> series
	 * @return ArrayList de Objetos COMENTARIOS.
	 */
	public List<Comentario> listasComent(long id,boolean m){	
		Connection con =null;
		PreparedStatement pst=null;
		ResultSet rs=null;
		Comentario result=null;
		List<Comentario> objList = new ArrayList<Comentario>();
		try{
			con= ds.getConnection();//Attempts to establish a connection with the data source that this DataSource object represents.
			String sql=null;
			//sql =" SELECT "+ enlace() +" from "+getTableName() + " natural join "+ cond(m) +" where " + cond2(m) + id + " and "+ cond3() ;
			sql =" SELECT "+ enlace() +" from "+getTableName() + cond(m) +" where " + cond2(m) + id + cond3() ;
			System.out.println(sql);
			pst = con.prepareStatement(sql);//An object that represents a pre-compiled SQL statement. 
			
			rs=pst.executeQuery();//Executes the SQL query in this PreparedStatement object and returns the ResultSet object generated by the query
			
			while(rs.next()){	
				result = buildObject(rs);//build the object obtain from the select
				objList.add(result);
			}
		}catch (SQLException e){
			e.printStackTrace();
		}finally{
			try{
				if(rs!=null) rs.close();
				if(pst!=null) pst.close();
				if(con!=null) con.close();
			}catch (Exception e){}
		}
		return objList;
	}	
	public static void main(String args[])
	        throws Exception
	    {
	 
	 //creamos y configuramos un objeto data source:
	 MysqlDataSource mysqlDataSource = new MysqlDataSource();
	 mysqlDataSource.setServerName("localhost");
	 mysqlDataSource.setDatabaseName("practica11");
	 mysqlDataSource.setPort(3306);
	 mysqlDataSource.setUser("root");
	 mysqlDataSource.setPassword("");
	 //establecemos la conexión con la BBDD, esto ya se hace dentro de cada una de las funciones antes listadas por eso prescindimos
	 //Connection con = mysqlDataSource .getConnection();
	 
	 //creamos un usuarioMapper, pasandole un objeto DataSource
	 ComentarioMapper mapCom = new ComentarioMapper( mysqlDataSource);
	
	 long id = 9223372036854775778L;//La L "the compiler will try to parse the literal as an int, hence the error message"
	 
	 //Ejemplo Insert
	 //Comentario com =new Comentario(id,"Marco","Una gran serie ");
	 //mapCom.Insert(com);	
	 
	
	 //Ejemplo Update
	 //Comentario com2=new Comentario(id,"Klaus","No me gusto el");
	 //mapCom.update(com2);
	 
	 //obligatorio para utiliar id´s 
	//UserKeys keyPer = new UserKeys(id);
	  
	 //Ejemplos Delete
	// mapCom.Delete(keyPer);
	 
	 //Ejemplos select
	 //Comentario com3 = new Comentario();
	 //com3 = mapCom.findById(keyPer);
	
	  // System.out.println(com3.getFecha());
	  
	  //Lista de comentarios 
//	 List<Comentario> coments; 
//	 Comentario comm =null;
//	 Comentario comm2 =null;
//	 long idE=9223372036854775801L;//id episodio
//	 coments= mapCom.listasObje(idE,true);
//	 comm= coments.get(0);
//	// comm2=coments.get(1);
//	 System.out.println(comm.getComentario());
	// System.out.println(comm2.getComentario());
	    }

	@Override
	protected String enlace() {
		String [] aux3= getColumnNames();
		String cond = " "+aux3[0]+","+aux3[1]+","+aux3[2]+","+aux3[3]+" ";
		return cond;
	}

	@Override
	protected String cond(boolean m) {
		String s=null;
		if(m){
			s= "  natural join  relcomepi ";
		}else if(!m){
			s=" natural join relcomser ";
		}
			return s;
	}

	@Override
	protected String cond2(boolean m) {
		String s=null;
		if(m){
			s= " id_epi= ";
		}else if(!m){
			s=" id_ser= ";
		}
			return s;
	}

	@Override
	protected String cond3() {
		String name =" and  id_com ";
		String [] val =getKeyColumnNames();
		String s= name+ " = " + val[0];
		return s;
	}

	

}
