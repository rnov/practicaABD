package database;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

import javax.sql.DataSource;

import model.Comentario;

import org.apache.commons.lang3.StringUtils;


public abstract class AbstractMapper <T,K> {
	protected DataSource ds;
	/**
	 * Devuelve el nombre de la tabla 
	 * @return String
	 */
	protected abstract String getTableName();
	/**
	 * Devuelve los nombres de las columnas de una tabla 
	 * @return Array Strings
	 */
	protected abstract String[] getColumnNames();
	protected abstract T buildObject (ResultSet rs) throws SQLException;

	protected abstract Object[] serializeKey(K key);
	protected abstract Object[] serializeObject(T object);
	
	
	/**
	 * Devuelve el nombre de las keys de una tabla
	 * @return Array Strings
	 */
	protected abstract String[] getKeyColumnNames();
	protected abstract K getKey(T obj);
	public AbstractMapper(DataSource dataSource){
		this.ds=dataSource;
	}
	
	public DataSource getDs() {
		return ds;
	}
	public void setDs(DataSource ds) {
		this.ds = ds;
	}

	/**
	 * Genera las condiciones where de una consulta a raíz de una serie de condiciones que se le han pasado previamente
	 * @param conditions
	 * @return String
	 */
	private String generateWhereConditions(QueryConditions[] conditions) {
		
		String result=" where ";
		String[] cadConditions=new String[conditions.length];
		for (int i = 0; i < conditions.length; i++) {
			cadConditions[i]=conditions[i].toString();
		}
		result+=StringUtils.join(cadConditions, " and ");
		return result;
	}
	private List<T> findByConditions(QueryConditions[] conditions) {
		// TODO Auto-generated method stub
		List<T> result= new LinkedList<T>();
		for (int i = 0; i < conditions.length; i++) {
			
		}
		return null;
	}
	/**
	 * Genera 
	 * @param id
	 * @return QueryConditions
	 */
	private QueryConditions[] getQueryConditionsFromKey(K id){
		String[] keyColumnNames= getKeyColumnNames();//obtenemos los nombres de las cols keys
		Object[] keyValues= serializeKey(id);//obtenemos el valor de las keys
		QueryConditions[] conditions= new QueryConditions[keyColumnNames.length];
		for (int i = 0; i < conditions.length; i++) {
			conditions[i]= new QueryConditions(keyColumnNames[i], Operator.EQ, keyValues[i]);
		}
		return conditions;
	}
		
	//-------------Genericas, sirven para todos los mappers			
	
	
	/**
	 * Se encarga de buscar en las tablas de la BBDD y devolver objetos a partir de un ID 
	 * @param id 
	 */
	public T findById(K id){	
		Connection con =null;
		PreparedStatement pst=null;
		ResultSet rs=null;
		T result=null;
		try{
			con= ds.getConnection();//Attempts to establish a connection with the data source that this DataSource object represents.
			QueryConditions[] conditions= getQueryConditionsFromKey(id);//Creamos condicion con id
			
			String whereConditions=generateWhereConditions(conditions);//String with 'where conditions'
			
			String sql="SELECT "+ " * "+" From "+getTableName() + whereConditions;//String with SQL statement
			
			pst = con.prepareStatement(sql);//An object that represents a pre-compiled SQL statement. 
			
			for (int i = 0; i < conditions.length; i++) {
				pst.setObject(i+1, conditions[i].getValor());
			}
			rs=pst.executeQuery();//Executes the SQL query in this PreparedStatement object and returns the ResultSet object generated by the query
			if(rs.next()){
				
				result = buildObject(rs);//build the object obtain from the select
			}
			
		}catch (SQLException e){
			e.printStackTrace();
		}finally{
			try{
				if(rs!=null) rs.close();
				if(pst!=null) pst.close();
				if(con!=null) con.close();
				
			}catch (Exception e){}
		}
		return result;
	}
	
	/**
	 * Modifica un objeto de la BBDD
	 * @param obj
	 */
	public  int update(T obj) {//T obj
		Connection con =null;
		PreparedStatement pst=null;
		int rs=0;//1fail, 0 success
		try{
			con= ds.getConnection();//Attempts to establish a connection with the data source that this DataSource object represents.
			String sql= null;
					//UPDATE table_name SET column1=value1,column2=value2,...WHERE some_column=some_value;
			
			sql =  " update " + getTableName()+" set "+pharseUpdate();// +" where " +getKeyColumnNames()+ "= ? ";
	
			pst = con.prepareStatement(sql);//An object that represents a pre-compiled SQL statement. 
			//rellenar las ? , una funcion que reciba un statement pst y un objeto obj y las rellene TODAS
			fill(pst,obj,false);
			
			
			rs = pst. executeUpdate();//El resultado int que nos devuelve no nos sirve para el caso de update, delete, insert, nos devolvera 0

			
			//String updateString =  "update " + dbName + ".COFFEES " +   "set SALES = ? where COF_NAME = ?";				   			  
			
		}catch (SQLException e){
			e.printStackTrace();
		}finally{
			try{
				if(pst!=null) pst.close();// close preparedStatement
				if(con!=null) con.close();//close connection
				
			}catch (Exception e){}
		}
		return rs;
	}
	/**
	 * Inserta un objeto nuevo en la BBDD
	 * @param obj
	 */
	public  int Insert(T obj) {
		Connection con =null;
		PreparedStatement pst=null;
		int rs=0;//1fail, 0 success
		try{
			con= ds.getConnection();//Attempts to establish a connection with the data source that this DataSource object represents.
			String sql= null;
			
				//sql =InsertStat(obj);//String with SQL statement
			sql = "Insert into "+getTableName()+pharseInsert();
			
			pst = con.prepareStatement(sql);//An object that represents a pre-compiled SQL statement. 
			
			//rellenar las ? , una funcion que reciba un statement pst y un objeto obj y las rellene TODAS
			fill(pst,obj,true);
			
			rs = pst. executeUpdate();//El resultado int que nos devuelve no nos sirve para el caso de update, delete, insert, nos devolvera 0

			
		}catch (SQLException e){
			e.printStackTrace();
		}finally{
			try{
				if(pst!=null) pst.close();// close preparedStatement
				if(con!=null) con.close();//close connection
				
			}catch (Exception e){}
		}
		return rs;
	}
	
	/**
	 * Se le pasa una ID y se ocupa de borar dicho columna de la tabla correspondiente de la BBDD	
	 * @param id
	 */
	public int Delete(K id) {
		Connection con =null;
		PreparedStatement pst=null;
		int rs=0;
		try{
			con= ds.getConnection();//Attempts to establish a connection with the data source that this DataSource object represents.
			
			QueryConditions[] conditions= getQueryConditionsFromKey(id);//Creamos condicion con id	
			String whereConditions=generateWhereConditions(conditions);//String with 'where conditions'

			
			//String sql="Delete from "+ getTableName()+ " where "+pharseDelete(id);//String with SQL statement
			String sql="Delete from "+ getTableName()+ whereConditions;
			
			pst = con.prepareStatement(sql);//An object that represents a pre-compiled SQL statement. 
			
			for (int i = 0; i < conditions.length; i++) {//leemos las condiciones para hacer el delete, es decir que lea la id que vaya a borrar
				pst.setObject(i+1,conditions[i].getValor());
			}
			
			rs = pst.executeUpdate();//Executes the SQL statement in this PreparedStatement object, 
									//which must be an SQL Data Manipulation Language (DML) statement, such as INSERT, UPDATE or DELETE; 
			
			
		}catch (SQLException e){
			e.printStackTrace();
		}finally{
			try{
				if(pst!=null) pst.close();
				if(con!=null) con.close();
				
			}catch (Exception e){}
		}
		return rs;
	}
	//---------------------
	
	//-----abstrarctas (se implementan dentro de cada mapper que hereda)
	/**
	 * Se encarga de rellenar el Statement con los atributos de los objetos, este método se utiliza en Update/Insert
	 * @param pst prepareStatement
	 * @param obj El objeto con el que rellenará el Statement
	 * @param ins , true si es insert false si es update
	 */
	protected abstract void fill(PreparedStatement pst , T obj,boolean ins);
	/**
	 * Devuelve la estructura en un String, de un update con las ? por rellenar 
	 * @return String
	 */
	protected abstract String pharseUpdate();
	
	/**
	 * String para parsear las consultas tipo insert, devuelve (col1,col2...) VALUES(value1,value2...) 
	 * @param obj
	 * @return String
	 */
	protected abstract String  pharseInsert();
	/*********************NUEVOS METODOS 24/4/14*****AbstractMapper***********************************/
	
	/**
	 * 
	 * @return
	 */
	protected abstract String enlace();
	/**
	 * 
	 * @param m
	 * @return 
	 */
	protected abstract String cond(boolean m);
	/**
	 * 
	 * @param m en el caso de comentarios true -> episodios , false-> series , para el resto true.
	 * @return
	 */
	protected abstract String cond2(boolean m);
	protected abstract String cond3();
	
	/**
	 * Metodo que devuelve ArrayList de objetos .
	 * Se ha utilizado para las busquedas que devuelven listas de la sección 2.2 , 3.2(lista series que usuario consta como seguidor)
	 * 1- String id-> id_usr, boolean m-> true , para saber un usuario que series sigue , devuleve ArrayList<Serie>
	 * 2- String id-> nombre(total o parcial Serie) , boolean m->false , busca series con el nombre y las devuelve ArrayList<Serie>
	 * @param id String de usr o nombre
	 * @param m true -> seguidor , false-> busqueda lista series
	 * @return ArrayList SERIES 
	 */
	public List<T> listasObje(String id,boolean m){	
		Connection con =null;
		PreparedStatement pst=null;
		ResultSet rs=null;
		T result=null;
		List<T> objList = new ArrayList<T>();
		try{
			con= ds.getConnection();//Attempts to establish a connection with the data source that this DataSource object represents.
			String sql=null;
		    //select * from series where series.nombre like "%sa%" ;	
			if(m)sql =" SELECT "+ enlace() +" from "+getTableName() + " natural join "+ cond(m) +" where " + cond2(m) + "'"+ id +"'"+" and "+ cond3();
			
			else if (!m)sql= "select * from series where series.nombre like "+"'%"+id+"%'";
			System.out.println(sql);
			pst = con.prepareStatement(sql);//An object that represents a pre-compiled SQL statement. 
			
			rs=pst.executeQuery();//Executes the SQL query in this PreparedStatement object and returns the ResultSet object generated by the query
			
			while(rs.next()){	
				result = buildObject(rs);//build the object obtain from the select
				objList.add(result);
			}
		}catch (SQLException e){
			e.printStackTrace();
		}finally{
			try{
				if(rs!=null) rs.close();
				if(pst!=null) pst.close();
				if(con!=null) con.close();
			}catch (Exception e){}
		}
		return objList;
	}	
	
	
	/**
	 * Metodo adaptado para el punto 3.1 , 3.2(episodios que el usuario no ha visto todavía de una serie). 
	 * NOTA: En caso de que los haya visto todos devolvera un null la busqueda e irá a SQLException.
	 * 1- String id != null(es el id_usr ) y id2 es el id_serie, Busca episodios de una serie que el usuario NO ha visto, devolverá un ArrayList<Episodios>
	 * 2- String id == null, y id2 es el id_serie, Busca los episodios correspondienes a esa serie, Devolvera los episodios de dicha serie en un ArrayList<Episodios>
	 * @param id un id String(correspondiente al id_usr)
	 * @param id2 un id long (correspondiente a id_ser)
	 * @return Arraylist con los EPISODIOS.
	 */
	public List<T> listasObje(String id,long id2){	
		Connection con =null;
		PreparedStatement pst=null;
		ResultSet rs=null;
		T result=null;
		List<T> objList = new ArrayList<T>();
		try{
			con= ds.getConnection();//Attempts to establish a connection with the data source that this DataSource object represents.
			String sql=null;
		
			if(id !=null){
				sql ="select episodios.id_episodio,episodios.id_ser,episodios.num_ord,episodios.num_temp,episodios.sinopsis,episodios.titulo,episodios.fecha_estr from episodios where episodios.id_ser ="+ id2+  
						" and episodios.id_episodio not in (select episodios.id_episodio from visto  natural join episodios where visto.id_usr="+"'"+id+"'"+ " and id_epi= id_episodio and episodios.id_ser ="+id2+")";
			}
					
			else{
				if (id ==null) {
					sql = "SELECT  *  from episodios   where  episodios.id_ser ="+id2;
				}
			}
			
			System.out.println(sql);
			pst = con.prepareStatement(sql);//An object that represents a pre-compiled SQL statement. 
			
			rs=pst.executeQuery();//Executes the SQL query in this PreparedStatement object and returns the ResultSet object generated by the query
			
			while(rs.next()){	
				result = buildObject(rs);//build the object obtain from the select
				objList.add(result);
			}
		}catch (SQLException e){
			e.printStackTrace();
		}finally{
			try{
				if(rs!=null) rs.close();
				if(pst!=null) pst.close();
				if(con!=null) con.close();
			}catch (Exception e){}
		}
		return objList;
	}	
	
}
