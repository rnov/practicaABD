package database;
import model.Voto;
import model.UserKeys;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;


//Imports para pruebas en main
import javax.sql.DataSource;

import com.mysql.jdbc.jdbc2.optional.MysqlDataSource;
//---

public class VotoMapper extends AbstractMapper<Voto,UserKeys> {

	public VotoMapper(DataSource dataSource) {
		super(dataSource);
		// TODO Auto-generated constructor stub
	}

	@Override
	protected String getTableName() {
		// TODO Auto-generated method stub
		return model.Constants.VOTO_TABLE;
	}

	@Override
	protected String[] getColumnNames() {
		// TODO Auto-generated method stub
		return new String[]{"id_voto", "id_usr", "valor"};
	}
	
	//@SuppressWarnings("null")
	@Override
	protected Voto buildObject(ResultSet rs) throws SQLException {
		Voto result = new Voto();
		result.setId_voto(rs.getLong("id_voto"));
		result.setId_usr(rs.getString("id_usr"));
		result.setValor(rs.getInt("valor"));
		return result;
	}

	@Override
	protected Object[] serializeKey(UserKeys key) {
		// TODO Auto-generated method stub
		return new Object[] { key.getKey() };
	}

	@Override
	protected Object[] serializeObject(Voto object) {
		// TODO Auto-generated method stub
		return new Object[] {object.getId_voto(),object.getId_usr(),object.getValor()};
	}

	@Override
	protected String[] getKeyColumnNames() {
		// TODO Auto-generated method stub
		String[] keyCol={"id_voto"};
		return keyCol;
	}

	@Override
	protected UserKeys getKey(Voto obj) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	protected void fill(PreparedStatement pst, Voto obj, boolean ins) {
		// TODO Auto-generated method stub
				try {	
					pst.setLong(1, obj.getId_voto());// ? id_voto
					pst.setString(2,obj.getId_usr());// ? id_usr
					pst.setInt(3,obj.getValor());// ? valor
					if(!ins){//si es update necesitamos rellenar la condicion where con el nick .
						pst.setLong(4, obj.getId_voto());
					}
					
				} catch (SQLException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
		
	}

	@Override
	protected String pharseUpdate() {
		String colNam[] = getColumnNames();
		String str = colNam[0]+"= ? ,"+colNam[1]+"= ? ,"+colNam[2]+"= ? where "+colNam[0]+"= ? ";
		return str;
	}

	@Override
	protected String pharseInsert() {
		String colNam[] = getColumnNames();
		String str = " ("+colNam[0]+","+colNam[1]+","+colNam[2]+")"
		+ " values " + " ( ?  , ? , ? ) ";
		return str;
	}
	public long getLastIndexInsert() {
		Connection con =null;
		PreparedStatement pst=null;
		ResultSet rs=null;
		Long result=null;
		try{
			con= ds.getConnection();//Attempts to establish a connection with the data source that this DataSource object represents.
			String sql="SELECT MAX( id_voto ) AS id FROM voto";
			pst = con.prepareStatement(sql);//An object that represents a pre-compiled SQL statement. 
			rs=pst.executeQuery();//Executes the SQL query in this PreparedStatement object and returns the ResultSet object generated by the query
			
			while(rs.next()){	
				result = rs.getLong("id");
			}
		}catch (SQLException e){
			e.printStackTrace();
		}finally{
			try{
				if(rs!=null) rs.close();
				if(pst!=null) pst.close();
				if(con!=null) con.close();
			}catch (Exception e){}
		}
		return result;
	}
	public static void main(String args[])
	        throws Exception
	    {
	 
	 //creamos y configuramos un objeto data source:
	 MysqlDataSource mysqlDataSource = new MysqlDataSource();
	 mysqlDataSource.setServerName("localhost");
	 mysqlDataSource.setDatabaseName("practica11");
	 mysqlDataSource.setPort(3306);
	 mysqlDataSource.setUser("root");
	 mysqlDataSource.setPassword("");
	 //establecemos la conexión con la BBDD, esto ya se hace dentro de cada una de las funciones antes listadas por eso prescindimos
	 //Connection con = mysqlDataSource .getConnection();
	 
	 //creamos un usuarioMapper, pasandole un objeto DataSource
	 //VotoMapper mapVoto = new VotoMapper( mysqlDataSource);
	
	 //long id = 9223372036854775778L;//La L "the compiler will try to parse the literal as an int, hence the error message"
	 
	 //Ejemplo Insert
	 //Voto voto=new Voto(id,"Klaus",5);
	 //mapVoto.Insert(voto);	
	 
	
	 //Ejemplo Update
	 //Voto voto2=new Voto(id,"Klaus",1);
	 //mapVoto.update(voto2);
	 
	 //obligatorio para utiliar id´s 
	 //UserKeys keyPer = new UserKeys(id);
	  
	 //Ejemplos Delete
	   //mapVoto.Delete(keyPer);
	 
	 //Ejemplos select
	    //Voto voto3 = new Voto();
	    //voto3 = mapVoto.findById(keyPer);
	
	   //System.out.println(voto3.getId_usr());
	    }

	@Override
	protected String enlace() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	protected String cond(boolean m) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	protected String cond2(boolean m) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	protected String cond3() {
		// TODO Auto-generated method stub
		return null;
	}

}
