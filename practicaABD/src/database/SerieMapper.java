package database;

import model.Comentario;
import model.Serie;
import model.UserKeys;

import java.sql.Connection;
import java.sql.Date;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.GregorianCalendar;



import java.util.List;



//Imports para pruebas en main
import javax.sql.DataSource;

import com.mysql.jdbc.jdbc2.optional.MysqlDataSource;
//---

public class SerieMapper extends AbstractMapper<Serie,UserKeys> {

	public SerieMapper(DataSource dataSource) {
		super(dataSource);
		// TODO Auto-generated constructor stub
	}

	@Override
	protected String getTableName() {
		// TODO Auto-generated method stub
		return  model.Constants.SERIE_TABLE ;
	}

	@Override
	protected String[] getColumnNames() {
		// TODO Auto-generated method stub
		return new String[]{"id_serie", "nombre", "titular", "sinopsis","anio_estreno","anio_final"};
	}

	//@SuppressWarnings("null")
	@Override
	protected Serie buildObject(ResultSet rs) throws SQLException {
		// TODO Auto-generated method stub
		Serie result = new Serie();
		result.setId_serie(rs.getLong("id_serie"));
		result.setNombre(rs.getString("nombre"));
		result.setSinopsis(rs.getString("sinopsis"));
		result.setTitular(rs.getString("titular"));
		result.setFech_Est(rs.getDate("anio_estreno"));
		result.setFech_fin(rs.getDate("anio_final"));
		return result;
	}


	@Override
	protected Object[] serializeObject(Serie object) {
		// TODO Auto-generated method stub
		return new Object[] {object.getId_serie(),object.getNombre(),object.getSinopsis(),object.getTitular(),object.getFech_Est(),object.getFech_fin()};
	}

	@Override
	protected String[] getKeyColumnNames() {
		// TODO Auto-generated method stub
		String[] keyCol={"id_serie"};
		return keyCol;
	}

	@Override
	protected UserKeys getKey(Serie obj) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	protected void fill(PreparedStatement pst, Serie obj, boolean ins) {
		// TODO Auto-generated method stub
		//BigDecimal d = new BigDecimal(obj.getId_serie());//apaño para trabajar con  biginteger en prepareStatement
		try {
			//pst.setBigDecimal(1, d);
			pst.setLong(1, obj.getId_serie());
			pst.setString(2,obj.getNombre());//? de nombre
			pst.setString(3,obj.getTitular());// ? de titular
			pst.setString(4,obj.getSinopsis());// ? sinopsis
			pst.setDate(5, obj.getFech_Est());// ? fechEstreno
			pst.setDate(6, obj.getFech_fin());// ? fechFin
			if(!ins){//si es update necesitamos rellenar la condicion where con el nick .
				pst.setLong(7, obj.getId_serie());
			}
			
		} catch (SQLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	@Override
	protected String pharseUpdate() {
		String colNam[] = getColumnNames();
		String str = colNam[0]+"= ? ,"+colNam[1]+"= ? ,"+colNam[2]+"= ? ,"+colNam[3]+"= ? ,"+colNam[4]+"= ? ,"+colNam[5]+"= ? where "+colNam[0]+"= ? ";
		return str;
	}

	@Override
	protected String pharseInsert() {
		String colNam[] = getColumnNames();//","+colNam[4]+","+colNam[5]// faltan fechas
		String str = " ("+colNam[0]+","+colNam[1]+","+colNam[2]+","+colNam[3]+","+colNam[4]+","+colNam[5]+")"
		+ " values " + " ( ?  , ? , ? , ? , ? , ? ) ";//Nota: No se puede insertar si no se rellenan todos los ?
		return str;
	}

	@Override
	protected Object[] serializeKey(UserKeys key) {
		// TODO Auto-generated method stub
		return new Object[] { key.getKey() };
	}
	/**
	 * Esta clase nos devuelve la media que tiene una serie o un episodio, solo necesita pasarle un id de serie o episodio.
	 *Este metodo es necesario solo en dos clases por ahora y corresponde al 4.1 del enunciado.
	 * @param id de la serie o episodio, que es un long en ambos casos
	 * @return Media de las notas que se le han dato a un/a serie/episodio
	 */
	public float media(long id){	
		Connection con =null;
		PreparedStatement pst=null;
		ResultSet rs=null;
		float media = 0;
		try{
			con= ds.getConnection();//Attempts to establish a connection with the data source that this DataSource object represents.
			
			String sql=null;
			
			String tipo[] = getColumnNames();//en serie tipo[0]=id_ser , en epi tipo[0]=id_epi
			
			 sql= " SELECT "+ " AVG(valor) "+ " From  voto  natural join "+ getTableName()  + " where "+tipo[0] +" = "+id; 
			
			pst = con.prepareStatement(sql);//An object that represents a pre-compiled SQL statement. 
			
			rs=pst.executeQuery();//Executes the SQL query in this PreparedStatement object and returns the ResultSet object generated by the query
			if(rs.next())media= rs.getFloat(1);//NOTA: El primer termino del indice es 1
				
		}catch (SQLException e){
			e.printStackTrace();
		}finally{
			try{
				if(rs!=null) rs.close();
				if(pst!=null) pst.close();
				if(con!=null) con.close();
			}catch (Exception e){}
		}
		return media;
	}
	/**
	 * Método génerico que se encarga de devolver lista de objetos de la BBDD.
	 * Se utiliza especialmente para devolver ArrayList de comentarios, es decir, devuelve comentarios tanto de series como de episodios dependiendo 
	 * de los valores que toma boolean m.Sección 5.1 y 5.2 
	 * @param id en el caso de los comentarios de la serie/episodio
	 * @param m true -> episodios , false-> series
	 * @return ArrayList de Objetos COMENTARIOS.
	 */
	public List<Serie> listaSeries(long id,boolean m){	
		Connection con =null;
		PreparedStatement pst=null;
		ResultSet rs=null;
		Serie result=null;
		List<Serie> objList = new ArrayList<Serie>();
		try{
			con= ds.getConnection();//Attempts to establish a connection with the data source that this DataSource object represents.
			String sql=null;
			//sql =" SELECT "+ enlace() +" from "+getTableName() + " natural join "+ cond(m) +" where " + cond2(m) + id + " and "+ cond3() ;
			sql =" SELECT "+ enlace() +" from "+getTableName() + cond(m) +" where " + cond2(m) + id + cond3() ;
			System.out.println(sql);
			pst = con.prepareStatement(sql);//An object that represents a pre-compiled SQL statement. 
			
			rs=pst.executeQuery();//Executes the SQL query in this PreparedStatement object and returns the ResultSet object generated by the query
			
			while(rs.next()){	
				result = buildObject(rs);//build the object obtain from the select
				objList.add(result);
			}
		}catch (SQLException e){
			e.printStackTrace();
		}finally{
			try{
				if(rs!=null) rs.close();
				if(pst!=null) pst.close();
				if(con!=null) con.close();
			}catch (Exception e){}
		}
		return objList;
	}	
	public static void main(String args[])
	        throws Exception
	    {
	 
	 //creamos y configuramos un objeto data source:
	 MysqlDataSource mysqlDataSource = new MysqlDataSource();
	 mysqlDataSource.setServerName("localhost");
	 mysqlDataSource.setDatabaseName("practica11");
	 mysqlDataSource.setPort(3306);
	 mysqlDataSource.setUser("root");
	 mysqlDataSource.setPassword("");
	 //establecemos la conexión con la BBDD, esto ya se hace dentro de cada una de las funciones antes listadas por eso prescindimos
	 //Connection con = mysqlDataSource .getConnection();
	 
	 //creamos un usuarioMapper, pasandole un objeto DataSource
	 SerieMapper mapSr = new SerieMapper( mysqlDataSource);
	
	 long id = 9223372036854775001L;//La L "the compiler will try to parse the literal as an int, hence the error message"
	 
	//--------------FECHA
	Calendar cale = new GregorianCalendar(2014,3,20);//NOTA: los meses empiezan en 0, es decir Enero=0, en la BBDD será 1.
	Date fecha = new Date(cale.getTimeInMillis());
	 
	 
	 //Ejemplo Insert
	 //Serie ser=new Serie(id,"Salem","...","En 1685 ...",fecha);
	 //mapSr.Insert(ser);	
	 
	
	 //Ejemplo Update
	// Serie ser2=new Serie(id,"The Walking Dead","...","....",fecha);
	 //mapSr.update(ser2);
	 
	 //obligatorio para utiliar id´s 
	// UserKeys keySerie = new UserKeys(id);
	  
	 //Ejemplos Delete
	   //mapSr.Delete(keySerie);
	  // mapSr.Delete("Mark") ;
	 
	 //Ejemplos select
	   // Serie ser3 = new Serie();
	    //ser3 = mapSr.findById(keySerie);
	
	  // System.out.println(ser.getFech_Est());
	 
	 	//PRUEBA de Listas
		 List<Serie> sers; 
		 Serie ser =null;
		 String NomSerie="the";
		 String idUsr = "mark";
		// sers= mapSr.listasObje(NomSerie,false);
		 sers= mapSr.listasObje(idUsr,true);
		 ser= sers.get(0);
		 System.out.println(ser.getNombre());
	 
	 
	    }

	@Override
	protected String enlace() {
		String [] aux3= getColumnNames();
		String cond = " "+aux3[0]+","+aux3[1]+","+aux3[2]+","+aux3[3]+","+aux3[4]+","+aux3[5]+" ";
		return cond;
	}

	@Override
	protected String cond(boolean m) {
		String s=null;
		if(m){
			s=" seguidor ";
		}else if (!m){
			
		};
		return s;
	}

	@Override
	protected String cond2(boolean m) {
		String s=null;
				if(m){
					s=" id_usr= ";
				};
				return s;
	}

	@Override
	protected String cond3() {
		{
			String name ="id_ser ";
			String [] val =getKeyColumnNames();
			String s= name+ " = " + val[0];
			return s;
	}
	}
	
}
