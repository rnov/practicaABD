package database;
import model.Actor;
import model.PersonajeActor;
import model.UserKeys;

import java.io.File;
import java.io.FileInputStream;
import java.sql.Connection;
import java.sql.Date;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;


//Imports para pruebas en main
import javax.sql.DataSource;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.GregorianCalendar;
import java.util.List;

import com.mysql.jdbc.jdbc2.optional.MysqlDataSource;
//---

public class ActorMapper extends AbstractMapper<Actor,UserKeys> {

	public ActorMapper(DataSource dataSource) {
		super(dataSource);
		// TODO Auto-generated constructor stub
	}

	@Override
	protected String getTableName() {
		// TODO Auto-generated method stub
		return model.Constants.ACTOR_TABLE;
	}

	@Override
	protected String[] getColumnNames() {
		// TODO Auto-generated method stub
		return new String[]{"id_actor", "nom_artistico","fecha_nac","img"};
	}


	protected Actor buildObject(ResultSet rs) throws SQLException {
		Actor result = new Actor();
		result.setId_actor(rs.getLong("id_actor"));
		result.setNom_artistico(rs.getString("nom_artistico"));
		result.setFech(rs.getDate("fecha_nac"));
		result.setPic(rs.getBinaryStream("img"));
		return result;
	}

	@Override
	protected Object[] serializeKey(UserKeys key) {
		// TODO Auto-generated method stub
		return new Object[] { key.getKey() };
	}

	@Override
	protected Object[] serializeObject(Actor object) {
		// TODO Auto-generated method stub
		return new Object[] {object.getId_actor(),object.getNom_artistico(),object.getFech(),object.getPic()};
	}

	@Override
	protected String[] getKeyColumnNames() {
		// TODO Auto-generated method stub
		String[] keyCol={"id_actor"};
		return keyCol;
	}

	@Override
	protected UserKeys getKey(Actor obj) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	protected void fill(PreparedStatement pst, Actor obj, boolean ins) {
		try {	//Faltan fecha_nac
			pst.setLong(1, obj.getId_actor());// ? id_actor
			pst.setString(2,obj.getNom_artistico());// ? nom artistico
			pst.setDate(3, obj.getFech());// ? fech
			pst.setBinaryStream(4, obj.getPic());// ? img
			if(!ins){//si es update necesitamos rellenar la condicion where con el nick .
				pst.setLong(5, obj.getId_actor());
			}
			
		} catch (SQLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	@Override
	protected String pharseUpdate() {
		String colNam[] = getColumnNames();
		String str = colNam[0]+"= ? ,"+colNam[1]+"= ? ,"+colNam[2]+"= ? ,"+colNam[3]+"= ? where "+colNam[0]+"= ? ";
		return str;
	}

	@Override
	protected String pharseInsert() {
		String colNam[] = getColumnNames();//Faltan fecha_nac
		String str = " ("+colNam[0]+","+colNam[1]+","+colNam[2]+","+colNam[3]+")"
		+ " values " + " ( ?  , ? , ? , ? ) ";//NOTA: No se puede insertar si no se rellenan todos los ?
		return str;
	}
	/**
	 * Metodo que devuelve un ArrayList de PersonajeActor (clase auxiliar del modelo que tiene nombre actor y su personaje)
	 * Al pasarle una id de un episodio , el metodo busca los nombres de los actrores  y de sus personajes de dicho episodio y los devuelve
	 * en un ArrayList
	 * @param id de un episodio
	 * @return ArrayList PersonajeActor
	 */
	public List<Actor> listaActores(){	
		Connection con =null;
		PreparedStatement pst=null;
		ResultSet rs=null;
		Actor result=null;
		List<Actor> objList = new ArrayList<Actor>();
		try{
			con= ds.getConnection();//Attempts to establish a connection with the data source that this DataSource object represents.
			String sql=null;
			
			sql ="select * from actores" ;
			System.out.println(sql);
			
			pst = con.prepareStatement(sql);//An object that represents a pre-compiled SQL statement. 
			
			rs=pst.executeQuery();//Executes the SQL query in this PreparedStatement object and returns the ResultSet object generated by the query
			
			while(rs.next()){	
				result = this.buildObject(rs);//build the object obtain from the select
				objList.add(result);
			}
		}catch (SQLException e){
			e.printStackTrace();
		}finally{
			try{
				if(rs!=null) rs.close();
				if(pst!=null) pst.close();
				if(con!=null) con.close();
			}catch (Exception e){}
		}
		return objList;
	}
	

	public long getLastIndexInsert() {
		Connection con =null;
		PreparedStatement pst=null;
		ResultSet rs=null;
		Long result=null;
		try{
			con= ds.getConnection();//Attempts to establish a connection with the data source that this DataSource object represents.
			String sql="SELECT MAX( id_actor ) AS id FROM actores";
			pst = con.prepareStatement(sql);//An object that represents a pre-compiled SQL statement. 
			rs=pst.executeQuery();//Executes the SQL query in this PreparedStatement object and returns the ResultSet object generated by the query
			
			while(rs.next()){	
				result = rs.getLong("id");
			}
		}catch (SQLException e){
			e.printStackTrace();
		}finally{
			try{
				if(rs!=null) rs.close();
				if(pst!=null) pst.close();
				if(con!=null) con.close();
			}catch (Exception e){}
		}
		return result;
	}
	public static void main(String args[])
	        throws Exception
	    {
	 
	 //creamos y configuramos un objeto data source:
	 MysqlDataSource mysqlDataSource = new MysqlDataSource();
	 mysqlDataSource.setServerName("localhost");
	 mysqlDataSource.setDatabaseName("practica11");
	 mysqlDataSource.setPort(3306);
	 mysqlDataSource.setUser("root");
	 mysqlDataSource.setPassword("");
	 //establecemos la conexión con la BBDD, esto ya se hace dentro de cada una de las funciones antes listadas por eso prescindimos
	 //Connection con = mysqlDataSource .getConnection();
	 
	 //creamos un usuarioMapper, pasandole un objeto DataSource
	 ActorMapper mapAct = new ActorMapper( mysqlDataSource);
	
	 long id = 9223372036854775751L;//La L "the compiler will try to parse the literal as an int, hence the error message"
	 
	 //--------------FECHA
	 Calendar cale = new GregorianCalendar(1973,8,14);//NOTA: los meses empiezan en 0, es decir Enero=0, en la BBDD será 1.
	 Date fecha = new Date(cale.getTimeInMillis());
	 
	 Calendar calen = new GregorianCalendar(1969,0,6);//NOTA: los meses empiezan en 0, es decir Enero=0, en la BBDD será 1.
	 Date fecha2 = new Date(calen.getTimeInMillis());
	 
	//--------------IMG
	 File file = new File ("C:/rick.jpg");//path , File
	 FileInputStream fis=null;//fileInputStream
	 fis = new FileInputStream(file);
		
	 File file2 = new File ("C:/Daryl.jpg");//path , File
	 FileInputStream fis2=new FileInputStream(file2);//fileInputStream
	 
	 
	 //Ejemplo Insert
	 //Actor act=new Actor(id,"Daryl",fecha2,fis2);
	 //mapAct.Insert(act);	
	 
	
	 //Ejemplo Update
	 Actor act2=new Actor(id,"Rick",fecha,fis);
	 mapAct.update(act2);
	 
	 //obligatorio para utiliar id´s 
	 //UserKeys keyAct = new UserKeys(id);
	  
	 //Ejemplos Delete
	 //mapAct.Delete(keyAct);
	 
	 //Ejemplos select
	 //Actor act3 = new Actor();
	 //act3 = mapAct.findById(keyAct);
	
	  //System.out.println(act3.getFech());
	    }

	@Override
	protected String enlace() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	protected String cond(boolean m) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	protected String cond2(boolean m) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	protected String cond3() {
		// TODO Auto-generated method stub
		return null;
	}
	
	
}
