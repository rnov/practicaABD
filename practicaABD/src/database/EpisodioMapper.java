package database;


import model.Episodio;
import model.Serie;
import model.UserKeys;

import java.sql.Connection;
import java.sql.Date;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Calendar;
import java.util.GregorianCalendar;





import java.util.List;


//Imports para pruebas en main
import javax.sql.DataSource;

import com.mysql.jdbc.jdbc2.optional.MysqlDataSource;
//---


public class EpisodioMapper extends AbstractMapper<Episodio,UserKeys>{

	public EpisodioMapper(DataSource dataSource) {
		super(dataSource);
		// TODO Auto-generated constructor stub
	}

	@Override
	protected String getTableName() {
		// TODO Auto-generated method stub
		return  model.Constants.EPISODIO_TABLE ;
	}

	@Override
	protected String[] getColumnNames() {
		// TODO Auto-generated method stub 
		return new String[]{"id_episodio","id_ser" ,"num_ord", "num_temp", "sinopsis","titulo","fecha_estr"};
	}
	

	@Override
	protected Episodio buildObject(ResultSet rs) throws SQLException {
		Episodio result = new Episodio();
		
		result.setId_episodio(rs.getLong("id_ser"));
		result.setNum_orden(rs.getInt("num_ord"));
		result.setNum_temp(rs.getInt("num_temp"));
		result.setSinopsis(rs.getString("sinopsis"));
		result.setTitulo(rs.getString("titulo"));
		result.setFech(rs.getDate("fecha_estr"));
		result.setId_episodio(rs.getLong("id_episodio"));
		return result;
	}

	@Override
	protected Object[] serializeKey(UserKeys key) {
		// TODO Auto-generated method stub
		return new Object[] { key.getKey() };
	}

	@Override
	protected Object[] serializeObject(Episodio object) {
		// TODO Auto-generated method stub
		return new Object[] {object.getId_episodio(),object.getId_ser(),object.getNum_orden(),object.getNum_temp(),object.getSinopsis(),object.getTitulo(),object.getFech()};
	}

	@Override
	protected String[] getKeyColumnNames() {
		// TODO Auto-generated method stub
		String[] keyCol={"id_episodio"};
		return keyCol;
	}

	@Override
	protected UserKeys getKey(Episodio obj) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	protected void fill(PreparedStatement pst, Episodio obj, boolean ins) {
		// TODO Auto-generated method stub
				//BigDecimal d = new BigDecimal(obj.getId_episodio());//apaño para trabajar con  biginteger en prepareStatement
				try {	
					pst.setLong(1, obj.getId_episodio());// ? id_epi
					pst.setLong(2, obj.getId_ser());// ? id_serie
					pst.setInt(3,obj.getNum_orden());//? nº orden
					pst.setInt(4,obj.getNum_temp());//?  nº temporada
					pst.setString(5,obj.getSinopsis());// ? sinopsis
					pst.setString(6,obj.getTitulo());// ? titulo
					pst.setDate(7, obj.getFech());// ? fech
					if(!ins){//si es update necesitamos rellenar la condicion where con el nick .
						pst.setLong(8, obj.getId_episodio());
					}
					
				} catch (SQLException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}

	@Override
	protected String pharseUpdate() {
		String colNam[] = getColumnNames();
		String str = colNam[0]+"= ? ,"+colNam[1]+"= ? ,"+colNam[2]+"= ? ,"+colNam[3]+"= ? ,"+colNam[4]+"= ? ,"+colNam[5]+"= ? ,"+colNam[6]+"= ? where "+colNam[0]+"= ? ";
		return str;
	}

	@Override
	protected String pharseInsert() {
		String colNam[] = getColumnNames();
		String str = " ("+colNam[0]+","+colNam[1]+","+colNam[2]+","+colNam[3]+","+colNam[4]+","+colNam[5]+","+colNam[6]+")"
		+ " values " + " ( ?  , ? , ? , ? , ? , ? , ? ) ";//Nota: No se puede insertar si no se rellena todos los ?
		return str;
	}
	/**
	 * Esta clase nos devuelve la media que tiene una serie o un episodio, solo necesita pasarle un id de serie o episodio.
	 *Este metodo es necesario solo en dos clases por ahora y corresponde al 4.1 del enunciado.
	 * @param id de la serie o episodio, que es un long en ambos casos
	 * @return Media de las notas que se le han dato a un/a serie/episodio
	 */
	public float media(long id){	
		Connection con =null;
		PreparedStatement pst=null;
		ResultSet rs=null;
		float media = 0;
		try{
			con= ds.getConnection();//Attempts to establish a connection with the data source that this DataSource object represents.
			
			String sql=null;
			
			String tipo[] = getColumnNames();//en serie tipo[0]=id_ser , en epi tipo[0]=id_epi
			
			 sql= " SELECT "+ " AVG(valor) "+ " From  voto  natural join "+ getTableName()  + " where "+tipo[0] +" = "+id; 
			
			pst = con.prepareStatement(sql);//An object that represents a pre-compiled SQL statement. 
			
			rs=pst.executeQuery();//Executes the SQL query in this PreparedStatement object and returns the ResultSet object generated by the query
			if(rs.next())media= rs.getFloat(1);//NOTA: El primer termino del indice es 1
				
		}catch (SQLException e){
			e.printStackTrace();
		}finally{
			try{
				if(rs!=null) rs.close();
				if(pst!=null) pst.close();
				if(con!=null) con.close();
			}catch (Exception e){}
		}
		return media;
	}
	public static void main(String args[])
	        throws Exception
	    {
	 
	 //creamos y configuramos un objeto data source:
	 MysqlDataSource mysqlDataSource = new MysqlDataSource();
	 mysqlDataSource.setServerName("localhost");
	 mysqlDataSource.setDatabaseName("practica11");
	 mysqlDataSource.setPort(3306);
	 mysqlDataSource.setUser("root");
	 mysqlDataSource.setPassword("");
	 //establecemos la conexión con la BBDD, esto ya se hace dentro de cada una de las funciones antes listadas por eso prescindimos
	 //Connection con = mysqlDataSource .getConnection();
	 
	 //creamos un usuarioMapper, pasandole un objeto DataSource
	 EpisodioMapper mapEpi = new EpisodioMapper( mysqlDataSource);
	
	 long id = 9223372036854775802L;//La L "the compiler will try to parse the literal as an int, hence the error message"
	 long idS=9223372036854775000L;
	//--------------FECHA
	 Calendar cale = new GregorianCalendar(2011,9,14);//NOTA: los meses empiezan en 0, es decir Enero=0, en la BBDD será 1.
	 Date fecha = new Date(cale.getTimeInMillis());
		 
		
	 //Ejemplo Insert
	 //Episodio epi=new Episodio(id,idS,2,1,"El apocalipsis...","stand",fecha);;
	// mapEpi.Insert(epi);	
	 
	
	 //Ejemplo Update
	 //Episodio epi2=new Episodio(id,idS,2,1,"El apocalipsis...","stand",fecha);
	 //mapEpi.update(epi2);
	 
	 //obligatorio para utiliar id´s 
	 UserKeys keyEpi = new UserKeys(id);
	  
	 //Ejemplos Delete
	   //mapEpi.Delete(keyEpi);
	 
	 //Ejemplos select
	   // Episodio epi3 = new Episodio();
	   // epi3 = mapEpi.findById(keyEpi);
	
	   //System.out.println(epi3.getFech());
	   
	   //Lista de Episodios
	 List<Episodio> epis; 
	 Episodio epi =null;
	long  idSs =9223372036854775000L;
	 String idN =" 'Mark' ";
	 epis= mapEpi.listasObje(idN,idSs);
	 //epis= mapEpi.listasObje(null,idSs);
	 
	epi = epis.get(0);
	System.out.println(epi.getTitulo());
	    }

	
	//SELECT  *  from episodios   where  episodios.id_ser ='9223372036854775000' ;
	//sql =" SELECT "+ enlace() +" from "+getTableName() + cond(m) +" where " + cond2(m) + id + cond3() ;
	@Override
	protected String enlace(){
		String [] aux3= getColumnNames();
		String cond = " "+aux3[0]+","+aux3[1]+","+aux3[2]+","+aux3[3]+","+aux3[4]+","+aux3[5]+","+aux3[6]+" ";
		return cond;
	}

	@Override
	protected String cond(boolean m) {
		String s ="";
		//if(m)s="";
		return s;
	}

	@Override
	protected String cond2(boolean m) {
		String s = " episodios.id_ser= ";
		return s;
	}

	@Override
	protected String cond3() {
		String s = "";
		return s;
	}


}

